Ανδρεάδης Δημοσθένης
Α.Μ. 1115201400321

Εργασία 2

Η εργασία περιλαμβάνει τα εξής αρχεία:
main.c              : Υλοποίηση της main του travelMonitor
childMain.c	        : Υλοποίηση της main του Monitor
parentAux.c	        : Βοηθητικές συναρτήσεις του travelMonitor
childAux.c	        : Βοηθητικές συναρτήσεις των Monitors
parentSignals.c	    : Συναρτήσεις διαχείρισης σημάτων του travelMonitor
childSignals.c	    : Συναρτήσεις διαχείρισης σημάτων των Monitors
communication.c	    : Συναρτήσεις για την επικοινωνία μεταξύ travelMonitor και Monitors
monitorDirList.c    : Συναρτήσεις για τη δομή με την οποία τηρούν τα directories τους τα Monitor
stats.c		        : Συναρτήσεις για τη δομή των στατιστικών του travelMonitor
mainFunctions.c     : Συναρτήσεις για τις εντολές που υποβάλλει ο χρήστης
stateList.c         : Συναρτήσεις για τη δομή των χωρών
recordList.c    	: Συναρτήσεις για τη δομή των Records
bloomFilter.c	    : Συναρτήσεις για τα Bloom Filter
skipList.c	        : Συναρτήσεις για τις Skip List
structs.h           : Οι δομές των εφαρμογών
functions.h         : Δηλώσεις των συναρτήσεων
Makefile	        : Μake και δημιουργία των executable travelMonitor και child
create_infiles.sh   : Bash script του (Β) σκέλους

Α) Εφαρμογή travelMonitor

Έχει γίνει υλοποίηση όλων των δομών που ζητούνται στην εκφώνηση. Χρησιμοποιούνται επιπλέον μια δομή Date για την αναπαράσταση των ημερομηνιών, μια συνδεδεμένη λίστα για την τήρηση των χωρών και μια ταξινομημένη συνδεδεμένη λίστα για την κατάχωριση των records (από τη HW1) και επιπλέον οι δομές:
- ChildMonitor	: Πίνακας για την τήρηση στοιχείων των Monitors από το travelMonitor
- MonitorDir	: Συνδεδεμένη λίστα για την τήρηση στοιχείων των directories από τα Monitor
- Stats		: Δομή που τηρεί πίνακες με τα στατιστικά των requests, καταχωρώντας στην θέση [i] κάθε πίνακα τα στοιχεία (date, country, virus, hit/miss) του "i" request

--- Ροή εκτέλεσης ---
Ξεκινώντας, η εφαρμογή travelMonitor δημιουργεί από δύο named pipes για κάθε Monitor Child, ένα για write και ένα για read δεδομένων, και κάνει fork τις numMonitors διεργασίες - παιδιά Monitors, οι οποίες εκτελούν το πρόγραμμα child.

Στη συνέχεια τα Monitors λαμβάνουν ως πρώτα δύο μηνύματα τα bufferSize, sizeOfBloom, αναλαμβάνουν τα directories round-robin, τα διαβάζουν, δημιουργούν τις αναγκαίες δομές (όπως στη HW1) και αναφέρουν ετοιμότητα στην parent διεργασία.

Το travelMonitor, μόλις ολοκληρωθεί αυτή η διαδικασία, περιμένει την λήψη εντολών χρήστη από το terminal.

--- Πρωτόκολλο επικοινωνίας ---
Για την αποστολή και τη λήψη μηνυμάτων μεταξύ travelMonitor και Monitors, γίνεται χρήση ενός κωδικοποιημένου char* μηνύματος, που από τον λήπτη αποθηκεύεται σε μια struct Message και έχει την εξής σύνθεση:

- Στην πρώτη θέση, ένα char που υποδηλώνει το είδος του μηνύματος,
- Στις επόμενες LENGTH == 10 θέσεις, το μέγεθος του κυρίως μηνύματος,
- Στις επόμενες strlen(κυρίως μήνυμα) θέσεις, το κυρίως μήνυμα,
- Στην τελευταία θέση ένα trailing ‘\0’.

(πχ “C0000000007marika\0”)

Η αποστολή του μηνύματος γίνεται τμηματικά, τοποθετώντας τόσους χαρακτήρες κάθε φορά όσους χωράει ο buffer, με χρήση της συνάρτησης sendMessage() και ανάλογο αριθμό κλήσεων της write.

Η λήψη του μηνύματος γίνεται επίσης τμηματικά με τον ίδιο τρόπο, με τη διαφορά ότι η αντίστοιχη συνάρτηση readMessage() χρησιμοποιείται τρεις φορές, μία για το κάθε κομμάτι του μεταδιδόμενου μηνύματος, και με το αναγκαίο πλήθος αριθμό της read. Συνεπώς, το συνολικό αποσταλέν μήνυμα λαμβάνεται ως εξής:
- Με το 1ο μήνυμα μήκους char, ο κωδικός του συνολικού μηνύματος,
- Με το 2ο μήνυμα, μήκους LENGTH, το μήκος του body του συνολικού μηνύματος,
- Με το 3ο μήνυμα, μήκους όσο δήλωσε το 2ο, το body του συνολικού μηνύματος.

Μετά τη λήψη, έχουμε πρόσβαση στην πληροφορία του μηνύματος μέσω του Struct Message στο οποίο το αποθηκεύσαμε. Με την analyseChildMessage() και την analyseMessage() γίνεται ανάλυση από το travelMonitor και το Monitor, αντίστοιχα, του κυρίως σώματος του μηνύματος. Ανάλογα με τον χαρακτήρα της πρώτης θέσης, μπορεί να χρειαστεί περαιτέρω αποκωδικοποίηση, καθώς η σύνθεση του body μπορεί να διαφέρει, πχ να αποτελείται από ένα ή παραπάνω char* ενωμένα με ειδικούς χαρακτήρες ή να μην περιέχεται και κανένας χαρακτήρας.

Για τον συντονισμό travelMonitor και Monitors χρησιμοποιείται, όπως προαναφέρθηκε μία μεταβλητή readyMonitors. Όποτε η εντολή που εισάγει ο χρήστης απαιτεί επικοινωνία με ένα ή περισσότερα Monitor, μειώνεται ισόποσα η μεταβλητή. Με κάθε απόκριση από Monitor, το travelMonitor αυξάνει τη μεταβλητή, μέχρι που επανεισέρχεται στον βρόχο αναμονής εντολής από τον χρήστη. Μόνη εξαίρεση είναι η περίπτωση που ο χρήστης μέσω terminal δίνει SIGUSR1 στον Monitor. Με το πέρας της ανάγνωσης των νέων αρχείων και της επικαιροποίησης των δομών, το Monitor αποστέλλει με τη σειρά του ένα SIGUSR1 στο travelMonitor προκειμένου να το βάλει σε κατάσταση αναμονής για διάβασμα μηνυμάτων από το pipe.

Η μεταφορά μηνυμάτων έχει δοκιμαστεί επιτυχώς με ελάχιστο μέγεθος bufferSize.

--- Αποστολή BloomFilter ---
Για να είναι δυνατή η μετάδοση BloomFilters μεγάλου μέγεθος (> 100.000 B) ακολουθείται η εξής μορφοποίηση από τα Monitors για το body του μηνύματος:

- VirusName, ακολουθούμενο από ";”
- Ένα int* indices, μετατετραμμένο σε char*, που έχει διατρέξει τα bitArrays και έχει αποθηκεύσει στη θέση:
	- [i], τον δείκτη στον οποίο συναντά μη μηδενικά bit (ως μέρος του αντίστοιχου int),
	- [i+1] το περιεχόμενο του αντίστοιχου δείκτη.
 
Το travelMonitor λαμβάνοντας τα μηνύματα των BloomFilter ελέγχει την ύπαρξη ή μη αντίστοιχου BloomFilter για τον κάθε ιό και, αναλόγως, δημιουργεί ή ανανεώνει με bitwise OR τα bitArrays.


--- Signals ---
Χρησιμοποιούνται signal handler στα Monitor και στο travelMonitor, που setάρουν το ανάλογο κάθε φορά flag. Με άλλη συνάρτηση ελέγχονται περιοδικά τα flag και γίνονται οι αναγκαίε ενέργειες ανάλογα με τα ζητούμενα της άσκησης.  

Το travelMonitor φροντίζει για το μπλοκάρισμα των σημάτων ενόσω τρέχει το αρχικό setup και η ανταλλαγή μηνυμάτων με τα Monitor. Τα Monitor μπλοκάρουν αντίστοιχα όσο βρίσκονται σε διαδικασία ανάγνωσης και αποστολής μηνυμάτων.

Τα σήματα (ανάλογα και με το πλήθος τους) λαμβάνονται μόλις απελευθερωθούν.

Πέραν του SIGKILL στο travelMonitor, οι εφαρμογές διαχειρίζονται όλα τα σήματα της εκφώνησης, εκτελούν τις αντίστοιχες συναρτήσεις και συνεχίζουν τη ροή τους κανονικά.


Για τις εισαγωγές στo bit array των Bloom Filter χρησιμοποιείται ένας int* και οι αναγκαίες bitwise πράξεις. Για τα levels των Skip List χρησιμοποιείται μία λίστα από next pointers, με μέγιστο ύψος της Skip List το ~log(πληθυσμός γής).

Έλεγχοι:
i.   Κατά την είσοδο γίνονται οι εξής:
     - ότι δόθηκε ο ορθός αριθμός ορισμάτων
     - ότι το directory που δίνεται ως όρισμα είναι υπαρκτό,
     - ότι τα μεγέθη (numMonitors, bufferSize, bloomSize) που δίνονται ως όρισμα είναι θετικόι αριθμοί,

ii.  Κατά την ανάγνωση του αρχείου γίνονται οι εξής:
     - ότι σε ένα record μετά από "NO" δεν υπάρχει ημερομηνία,
     - ότι, σε περίπτωση identical citizenID, όλα τα στοιχεία του record είναι identical, εκτός του virus,
     - αν σε record που είναι identical με άλλο δοθεί ίδιο virus, απορρίπτεται η δεύτερη εγγραφή,
     - αν σε record που είναι identical με άλλο δοθεί νέο virus, αυτό προστίθεται στα viruses του υφιστάμενου record,

iii. Κατά την εκτέλεση των εντολών χρήστη, γίνονται οι εξής έλεγχοι, με εμφάνιση κατάλληλων μηνυμάτων στον χρήστη σε περίπτωση λάθους:
     - ότι δίνεται ο κατάλληλος κάθε φορά αριθμός ορισμάτων,
     - (για τις ανάλογες εντολές) ότι το country ή/και το virus όρισμα που δίνονται αφορούν υπαρκτή χώρα ή ιό,
     - (για τις εντολές καταχώρισης νέου record) ότι το citizenID αποτελείται από ψηφία, το date δίνεται στο σωστό format, το record δεν ειναι incosistent, το record δεν έχει ήδη εμβολιαστεί για τον ιό που δίνεται,

Γίνεται σωστή αποδέσμευση της μνήμης που χρησιμοποιεί η εφαρμογή, με ενδεικτική εκτέλεση:
make clean
make
valgrind --track-origins=yes --leak-check=full --show-leak-kinds=all --trace-children=yes ./travelMonitor -m 7 -b 10 -s 100000 -i input_dir/


Β) Script create_infiles.sh

i.  Κατά την είσοδο γίνονται οι εξής έλεγχοι, με την εμφάνιση κάθε φορά κατάλληλου μηνύματος:
    - ότι δόθηκε ο ορθός αριθμός παραμέτρων,
    - ότι η πρώτη παράμετρος (inputFile) είναι υπαρκτό αρχείο,
    - ότι η δεύτερη παράμετρος (input_dir) περιέχει μόνο έγκυρους για ονόματα καταλόγων χαρακτήρες (σαν σχεδιαστική επιλογή δεν γίνονται δεκτά κενά και ειδικοί χαρακτήρες πέραν των "-" και "_".),
    - ότι δεν υφίσταται κατάλογος με το όνομα που δίνεται ως δεύτερο όρισμα
    - ότι η τρίτη παράμετρος (numFilesPerDirectory) είναι θετικός ακέραιος αριθμός,

ii.  Για την δημιουργία των καταλόγων και των αρχειών χρησιμοποιείται μια associative array που αποθηκεύει ως κλειδί την κάθε χώρα και ως value τον αριθμό αρχείου κάθε χώρας που έπεται για γράψιμο.
     Έτσι, δεν απαιτείται πάνω από μία ανάγνωση του input_file για την παραγωγή directories και αρχείων και για την round-robin κατανομή των εγγραφών.

iii. Το script δοκιμάστηκε για τον χρόνο εκτέλεσης, με ενδεικτικά αποτελέσματα gia inpute files 500 και 20.000 εγγραφών, αντίστοιχα:
    
    time ./create_infiles.sh inputFile500.txt input_dir 4

    real	0m1,365s
    user	0m1,100s
    sys 	0m0,301s


    time ./create_infiles.sh inputFile5k.txt input_dir 4

    real	0m25,122s
    user	0m19,106s
    sys	    0m4,244s


    time ./create_infiles.sh inputFile20k.txt input_dir 4

    real	0m59,244s
    user	0m43,011s
    sys 	0m12,060s